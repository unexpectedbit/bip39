!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).eip2333=f()}}((function(){return function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,(function(r){return o(e[i][1][r]||r)}),p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}({1:[function(require,module,exports){module.exports.blskeygen=require("bls12-381-keygen"),module.exports.noblebls=require("noble-bls12-381")},{"bls12-381-keygen":2,"noble-bls12-381":5}],2:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deriveSeedTree=exports.deriveChild=exports.deriveMaster=exports.hkdfModR=void 0;const fast_sha256_1=require("fast-sha256"),blsR=52435875175126190479447740508185965837690552500527637822603658699938581184513n;function numberToBytesPadded(num,length=32){return function(hex){if("string"!=typeof hex)throw new TypeError("hexToBytes: expected string, got "+typeof hex);if(hex.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const array=new Uint8Array(hex.length/2);for(let i=0;i<array.length;i++){const j=2*i;array[i]=Number.parseInt(hex.slice(j,j+2),16)}return array}(function(num){const hex=num.toString(16);return 1&hex.length?`0${hex}`:hex}(num).padStart(2*length,"0"))}function os2ip(bytes){let result=0n;for(let i=0;i<bytes.length;i++)result<<=8n,result+=BigInt(bytes[i]);return result}function concatBytes(...arrays){if(1===arrays.length)return arrays[0];const length=arrays.reduce(((a,arr)=>a+arr.length),0),result=new Uint8Array(length);for(let i=0,pad=0;i<arrays.length;i++){const arr=arrays[i];result.set(arr,pad),pad+=arr.length}return result}function ikmToLamportSK(ikm,salt){const okm=fast_sha256_1.hkdf(ikm,salt,void 0,8160);return Array.from({length:255},((_,i)=>okm.slice(32*i,32*(i+1))))}function parentSKToLamportPK(parentSK,index){if(!(parentSK instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(!Number.isSafeInteger(index)||index<0||index>=2**32)throw new TypeError("Expected positive number");const salt=function(value,length){if(value<0||value>=1n<<BigInt(8*length))throw new Error(`bad I2OSP call: value=${value} length=${length}`);const res=Array.from({length:length}).fill(0);for(let i=length-1;i>=0;i--)res[i]=255&value,value>>>=8;return new Uint8Array(res)}(index,4),ikm=parentSK,lamport0=ikmToLamportSK(ikm,salt),lamport1=ikmToLamportSK(ikm.map((byte=>~byte)),salt),lamportPK=lamport0.concat(lamport1).map((part=>fast_sha256_1.hash(part)));return fast_sha256_1.hash(concatBytes(...lamportPK))}function hkdfModR(ikm,keyInfo=new Uint8Array){let salt=(str="BLS-SIG-KEYGEN-SALT-",(new TextEncoder).encode(str));var str;let SK=0n;const input=concatBytes(ikm,Uint8Array.from([0])),label=concatBytes(keyInfo,Uint8Array.from([0,48]));for(;0n===SK;){salt=fast_sha256_1.hash(salt);SK=os2ip(fast_sha256_1.hkdf(input,salt,label,48))%blsR}return numberToBytesPadded(SK)}function deriveMaster(seed){return hkdfModR(seed)}function deriveChild(parentKey,index){return hkdfModR(parentSKToLamportPK(parentKey,index))}exports.hkdfModR=hkdfModR,exports.deriveMaster=deriveMaster,exports.deriveChild=deriveChild,exports.deriveSeedTree=function(seed,path){if("string"!=typeof path)throw new Error("Derivation path must be string");const indices=path.split("/");if("m"!==indices.shift())throw new Error('First character of path must be "m"');const nodes=indices.map((i=>Number.parseInt(i)));let sk=deriveMaster(seed);for(const node of nodes)sk=deriveChild(sk,node);return sk}},{"fast-sha256":4}],3:[function(require,module,exports){},{}],4:[function(require,module,exports){!function(root,factory){var exports={};!function(exports){"use strict";exports.__esModule=!0,exports.digestLength=32,exports.blockSize=64;var K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);function hashBlocks(w,v,p,pos,len){for(var a,b,c,d,e,f,g,h,u,i,j,t1,t2;len>=64;){for(a=v[0],b=v[1],c=v[2],d=v[3],e=v[4],f=v[5],g=v[6],h=v[7],i=0;i<16;i++)j=pos+4*i,w[i]=(255&p[j])<<24|(255&p[j+1])<<16|(255&p[j+2])<<8|255&p[j+3];for(i=16;i<64;i++)t1=((u=w[i-2])>>>17|u<<15)^(u>>>19|u<<13)^u>>>10,t2=((u=w[i-15])>>>7|u<<25)^(u>>>18|u<<14)^u>>>3,w[i]=(t1+w[i-7]|0)+(t2+w[i-16]|0);for(i=0;i<64;i++)t1=(((e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7))+(e&f^~e&g)|0)+(h+(K[i]+w[i]|0)|0)|0,t2=((a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10))+(a&b^a&c^b&c)|0,h=g,g=f,f=e,e=d+t1|0,d=c,c=b,b=a,a=t1+t2|0;v[0]+=a,v[1]+=b,v[2]+=c,v[3]+=d,v[4]+=e,v[5]+=f,v[6]+=g,v[7]+=h,pos+=64,len-=64}return pos}var Hash=function(){function Hash(){this.digestLength=exports.digestLength,this.blockSize=exports.blockSize,this.state=new Int32Array(8),this.temp=new Int32Array(64),this.buffer=new Uint8Array(128),this.bufferLength=0,this.bytesHashed=0,this.finished=!1,this.reset()}return Hash.prototype.reset=function(){return this.state[0]=1779033703,this.state[1]=3144134277,this.state[2]=1013904242,this.state[3]=2773480762,this.state[4]=1359893119,this.state[5]=2600822924,this.state[6]=528734635,this.state[7]=1541459225,this.bufferLength=0,this.bytesHashed=0,this.finished=!1,this},Hash.prototype.clean=function(){for(var i=0;i<this.buffer.length;i++)this.buffer[i]=0;for(i=0;i<this.temp.length;i++)this.temp[i]=0;this.reset()},Hash.prototype.update=function(data,dataLength){if(void 0===dataLength&&(dataLength=data.length),this.finished)throw new Error("SHA256: can't update because hash was finished.");var dataPos=0;if(this.bytesHashed+=dataLength,this.bufferLength>0){for(;this.bufferLength<64&&dataLength>0;)this.buffer[this.bufferLength++]=data[dataPos++],dataLength--;64===this.bufferLength&&(hashBlocks(this.temp,this.state,this.buffer,0,64),this.bufferLength=0)}for(dataLength>=64&&(dataPos=hashBlocks(this.temp,this.state,data,dataPos,dataLength),dataLength%=64);dataLength>0;)this.buffer[this.bufferLength++]=data[dataPos++],dataLength--;return this},Hash.prototype.finish=function(out){if(!this.finished){var bytesHashed=this.bytesHashed,left=this.bufferLength,bitLenHi=bytesHashed/536870912|0,bitLenLo=bytesHashed<<3,padLength=bytesHashed%64<56?64:128;this.buffer[left]=128;for(var i=left+1;i<padLength-8;i++)this.buffer[i]=0;this.buffer[padLength-8]=bitLenHi>>>24&255,this.buffer[padLength-7]=bitLenHi>>>16&255,this.buffer[padLength-6]=bitLenHi>>>8&255,this.buffer[padLength-5]=bitLenHi>>>0&255,this.buffer[padLength-4]=bitLenLo>>>24&255,this.buffer[padLength-3]=bitLenLo>>>16&255,this.buffer[padLength-2]=bitLenLo>>>8&255,this.buffer[padLength-1]=bitLenLo>>>0&255,hashBlocks(this.temp,this.state,this.buffer,0,padLength),this.finished=!0}for(i=0;i<8;i++)out[4*i+0]=this.state[i]>>>24&255,out[4*i+1]=this.state[i]>>>16&255,out[4*i+2]=this.state[i]>>>8&255,out[4*i+3]=this.state[i]>>>0&255;return this},Hash.prototype.digest=function(){var out=new Uint8Array(this.digestLength);return this.finish(out),out},Hash.prototype._saveState=function(out){for(var i=0;i<this.state.length;i++)out[i]=this.state[i]},Hash.prototype._restoreState=function(from,bytesHashed){for(var i=0;i<this.state.length;i++)this.state[i]=from[i];this.bytesHashed=bytesHashed,this.finished=!1,this.bufferLength=0},Hash}();exports.Hash=Hash;var HMAC=function(){function HMAC(key){this.inner=new Hash,this.outer=new Hash,this.blockSize=this.inner.blockSize,this.digestLength=this.inner.digestLength;var pad=new Uint8Array(this.blockSize);if(key.length>this.blockSize)(new Hash).update(key).finish(pad).clean();else for(var i=0;i<key.length;i++)pad[i]=key[i];for(i=0;i<pad.length;i++)pad[i]^=54;this.inner.update(pad);for(i=0;i<pad.length;i++)pad[i]^=106;this.outer.update(pad),this.istate=new Uint32Array(8),this.ostate=new Uint32Array(8),this.inner._saveState(this.istate),this.outer._saveState(this.ostate);for(i=0;i<pad.length;i++)pad[i]=0}return HMAC.prototype.reset=function(){return this.inner._restoreState(this.istate,this.inner.blockSize),this.outer._restoreState(this.ostate,this.outer.blockSize),this},HMAC.prototype.clean=function(){for(var i=0;i<this.istate.length;i++)this.ostate[i]=this.istate[i]=0;this.inner.clean(),this.outer.clean()},HMAC.prototype.update=function(data){return this.inner.update(data),this},HMAC.prototype.finish=function(out){return this.outer.finished?this.outer.finish(out):(this.inner.finish(out),this.outer.update(out,this.digestLength).finish(out)),this},HMAC.prototype.digest=function(){var out=new Uint8Array(this.digestLength);return this.finish(out),out},HMAC}();function hash(data){var h=(new Hash).update(data),digest=h.digest();return h.clean(),digest}function hmac(key,data){var h=new HMAC(key).update(data),digest=h.digest();return h.clean(),digest}function fillBuffer(buffer,hmac,info,counter){var num=counter[0];if(0===num)throw new Error("hkdf: cannot expand more");hmac.reset(),num>1&&hmac.update(buffer),info&&hmac.update(info),hmac.update(counter),hmac.finish(buffer),counter[0]++}exports.HMAC=HMAC,exports.hash=hash,exports.default=hash,exports.hmac=hmac;var hkdfSalt=new Uint8Array(exports.digestLength);function hkdf(key,salt,info,length){void 0===salt&&(salt=hkdfSalt),void 0===length&&(length=32);for(var counter=new Uint8Array([1]),okm=hmac(salt,key),hmac_=new HMAC(okm),buffer=new Uint8Array(hmac_.digestLength),bufpos=buffer.length,out=new Uint8Array(length),i=0;i<length;i++)bufpos===buffer.length&&(fillBuffer(buffer,hmac_,info,counter),bufpos=0),out[i]=buffer[bufpos++];return hmac_.clean(),buffer.fill(0),counter.fill(0),out}function pbkdf2(password,salt,iterations,dkLen){for(var prf=new HMAC(password),len=prf.digestLength,ctr=new Uint8Array(4),t=new Uint8Array(len),u=new Uint8Array(len),dk=new Uint8Array(dkLen),i=0;i*len<dkLen;i++){var c=i+1;ctr[0]=c>>>24&255,ctr[1]=c>>>16&255,ctr[2]=c>>>8&255,ctr[3]=c>>>0&255,prf.reset(),prf.update(salt),prf.update(ctr),prf.finish(u);for(var j=0;j<len;j++)t[j]=u[j];for(j=2;j<=iterations;j++){prf.reset(),prf.update(u).finish(u);for(var k=0;k<len;k++)t[k]^=u[k]}for(j=0;j<len&&i*len+j<dkLen;j++)dk[i*len+j]=t[j]}for(i=0;i<len;i++)t[i]=u[i]=0;for(i=0;i<4;i++)ctr[i]=0;return prf.clean(),dk}exports.hkdf=hkdf,exports.pbkdf2=pbkdf2}(exports);var sha256=exports.default;for(var k in exports)sha256[k]=exports[k];"object"==typeof module&&"object"==typeof module.exports?module.exports=sha256:root.sha256=sha256}(this)},{}],5:[function(require,module,exports){(function(process){(function(){"use strict";
/*! noble-bls12-381 - MIT License (c) Paul Miller (paulmillr.com) */Object.defineProperty(exports,"__esModule",{value:!0}),exports.verifyBatch=exports.aggregateSignatures=exports.aggregatePublicKeys=exports.verify=exports.sign=exports.getPublicKey=exports.pairing=exports.PointG2=exports.PointG1=exports.utils=exports.CURVE=exports.Fp12=exports.Fp2=exports.Fr=exports.Fp=void 0;const math_1=require("./math");Object.defineProperty(exports,"Fp",{enumerable:!0,get:function(){return math_1.Fp}}),Object.defineProperty(exports,"Fr",{enumerable:!0,get:function(){return math_1.Fr}}),Object.defineProperty(exports,"Fp2",{enumerable:!0,get:function(){return math_1.Fp2}}),Object.defineProperty(exports,"Fp12",{enumerable:!0,get:function(){return math_1.Fp12}}),Object.defineProperty(exports,"CURVE",{enumerable:!0,get:function(){return math_1.CURVE}});const POW_2_381=2n**381n,POW_2_382=2n*POW_2_381,POW_2_383=2n*POW_2_382;let DST_LABEL="BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_";function bytesToNumberBE(bytes){let value=0n;for(let i=bytes.length-1,j=0;i>=0;i--,j++)value+=(255n&BigInt(bytes[i]))<<8n*BigInt(j);return value}function bytesToHex(uint8a){let hex="";for(let i=0;i<uint8a.length;i++)hex+=uint8a[i].toString(16).padStart(2,"0");return hex}function hexToBytes(hex){if("string"!=typeof hex)throw new TypeError("hexToBytes: expected string, got "+typeof hex);if(hex.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const array=new Uint8Array(hex.length/2);for(let i=0;i<array.length;i++){const j=2*i;array[i]=Number.parseInt(hex.slice(j,j+2),16)}return array}function toPaddedHex(num,padding){if(num<0n)throw new Error("Expected valid number");if("number"!=typeof padding)throw new TypeError("Expected valid padding");return num.toString(16).padStart(2*padding,"0")}function ensureBytes(hex){if(hex instanceof Uint8Array)return hex;if("string"==typeof hex)return hexToBytes(hex);throw new TypeError("Expected hex string or Uint8Array")}function concatBytes(...arrays){if(1===arrays.length)return arrays[0];const length=arrays.reduce(((a,arr)=>a+arr.length),0),result=new Uint8Array(length);for(let i=0,pad=0;i<arrays.length;i++){const arr=arrays[i];result.set(arr,pad),pad+=arr.length}return result}function os2ip(bytes){let result=0n;for(let i=0;i<bytes.length;i++)result<<=8n,result+=BigInt(bytes[i]);return result}function i2osp(value,length){if(value<0||value>=1<<8*length)throw new Error(`bad I2OSP call: value=${value} length=${length}`);const res=Array.from({length:length}).fill(0);for(let i=length-1;i>=0;i--)res[i]=255&value,value>>>=8;return new Uint8Array(res)}function strxor(a,b){const arr=new Uint8Array(a.length);for(let i=0;i<a.length;i++)arr[i]=a[i]^b[i];return arr}async function hash_to_field(msg,degree,isRandomOracle=!0){const count=isRandomOracle?2:1,m=degree,len_in_bytes=count*m*64,DST=function(str){const bytes=new Uint8Array(str.length);for(let i=0;i<str.length;i++)bytes[i]=str.charCodeAt(i);return bytes}(DST_LABEL),pseudo_random_bytes=await async function(msg,DST,lenInBytes){const H=exports.utils.sha256,ell=Math.ceil(lenInBytes/32);if(ell>255)throw new Error("Invalid xmd length");const DST_prime=concatBytes(DST,i2osp(DST.length,1)),Z_pad=i2osp(0,64),l_i_b_str=i2osp(lenInBytes,2),b=new Array(ell),b_0=await H(concatBytes(Z_pad,msg,l_i_b_str,i2osp(0,1),DST_prime));b[0]=await H(concatBytes(b_0,i2osp(1,1),DST_prime));for(let i=1;i<=ell;i++){const args=[strxor(b_0,b[i-1]),i2osp(i+1,1),DST_prime];b[i]=await H(concatBytes(...args))}return concatBytes(...b).slice(0,lenInBytes)}(msg,DST,len_in_bytes),u=new Array(count);for(let i=0;i<count;i++){const e=new Array(m);for(let j=0;j<m;j++){const elm_offset=64*(j+i*m),tv=pseudo_random_bytes.slice(elm_offset,elm_offset+64);e[j]=math_1.mod(os2ip(tv),math_1.CURVE.P)}u[i]=e}return u}function normalizePrivKey(key){let int;if(key instanceof Uint8Array&&32===key.length)int=bytesToNumberBE(key);else if("string"==typeof key&&64===key.length)int=BigInt(`0x${key}`);else if("number"==typeof key&&key>0&&Number.isSafeInteger(key))int=BigInt(key);else{if(!("bigint"==typeof key&&key>0n))throw new TypeError("Expected valid private key");int=key}if(int=math_1.mod(int,math_1.CURVE.r),int<1n)throw new Error("Private key must be 0 < key < CURVE.r");return int}exports.utils={async sha256(message){if("object"==typeof self&&"crypto"in self){const buffer=await self.crypto.subtle.digest("SHA-256",message.buffer);return new Uint8Array(buffer)}if("object"==typeof process&&"node"in process.versions){const{createHash:createHash}=require("crypto"),hash=createHash("sha256");return hash.update(message),Uint8Array.from(hash.digest())}throw new Error("The environment doesn't have sha256 function")},randomBytes:(bytesLength=32)=>{if("object"==typeof self&&"crypto"in self)return self.crypto.getRandomValues(new Uint8Array(bytesLength));if("object"==typeof process&&"node"in process.versions){const{randomBytes:randomBytes}=require("crypto");return new Uint8Array(randomBytes(bytesLength).buffer)}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>{let i=32;for(;i--;){const b32=exports.utils.randomBytes(32),num=bytesToNumberBE(b32);if(num>1n&&num<math_1.CURVE.r)return b32}throw new Error("Valid private key was not found in 32 iterations. PRNG is broken")},mod:math_1.mod,getDSTLabel:()=>DST_LABEL,setDSTLabel(newLabel){if("string"!=typeof newLabel||newLabel.length>2048||0===newLabel.length)throw new TypeError("Invalid DST");DST_LABEL=newLabel}};class PointG1 extends math_1.ProjectivePoint{constructor(x,y,z=math_1.Fp.ONE){super(x,y,z,math_1.Fp)}static fromHex(bytes){bytes=ensureBytes(bytes);const{P:P}=math_1.CURVE;let point;if(48===bytes.length){const compressedValue=bytesToNumberBE(bytes);if(1n===math_1.mod(compressedValue,POW_2_383)/POW_2_382)return this.ZERO;const x=new math_1.Fp(math_1.mod(compressedValue,POW_2_381));let y=x.pow(3n).add(new math_1.Fp(math_1.CURVE.b)).sqrt();const aflag=math_1.mod(compressedValue,POW_2_382)/POW_2_381;2n*y.value/P!==aflag&&(y=y.negate()),point=new PointG1(x,y)}else{if(96!==bytes.length)throw new Error("Invalid point G1, expected 48/96 bytes");{if(0!=(64&bytes[0]))return PointG1.ZERO;const x=bytesToNumberBE(bytes.slice(0,48)),y=bytesToNumberBE(bytes.slice(48));point=new PointG1(new math_1.Fp(x),new math_1.Fp(y))}}return point.assertValidity(),point}static fromPrivateKey(privateKey){return this.BASE.multiplyPrecomputed(normalizePrivKey(privateKey))}toRawBytes(isCompressed=!1){return hexToBytes(this.toHex(isCompressed))}toHex(isCompressed=!1){this.assertValidity();const{P:P}=math_1.CURVE;if(isCompressed){let hex;if(this.isZero())hex=POW_2_383+POW_2_382;else{const[x,y]=this.toAffine(),flag=2n*y.value/P;hex=x.value+flag*POW_2_381+POW_2_383}return toPaddedHex(hex,48)}if(this.isZero())return"4".padEnd(192,"0");{const[x,y]=this.toAffine();return toPaddedHex(x.value,48)+toPaddedHex(y.value,48)}}assertValidity(){if(this.isZero())return this;if(!this.isOnCurve())throw new Error("Invalid G1 point: not on curve Fp");if(!this.isTorsionFree())throw new Error("Invalid G1 point: must be of prime-order subgroup");return this}[Symbol.for("nodejs.util.inspect.custom")](){return this.toString()}millerLoop(P){return math_1.millerLoop(P.pairingPrecomputes(),this.toAffine())}clearCofactor(){return this.multiplyUnsafe(math_1.CURVE.hEff)}isOnCurve(){const b=new math_1.Fp(math_1.CURVE.b),{x:x,y:y,z:z}=this,left=y.pow(2n).multiply(z).subtract(x.pow(3n)),right=b.multiply(z.pow(3n));return left.subtract(right).isZero()}isTorsionFree(){return!this.clearCofactor().isZero()}}exports.PointG1=PointG1,PointG1.BASE=new PointG1(new math_1.Fp(math_1.CURVE.Gx),new math_1.Fp(math_1.CURVE.Gy),math_1.Fp.ONE),PointG1.ZERO=new PointG1(math_1.Fp.ONE,math_1.Fp.ONE,math_1.Fp.ZERO);class PointG2 extends math_1.ProjectivePoint{constructor(x,y,z=math_1.Fp2.ONE){super(x,y,z,math_1.Fp2)}static async hashToCurve(msg){msg=ensureBytes(msg);const u=await hash_to_field(msg,2),Q0=new PointG2(...math_1.isogenyMapG2(math_1.map_to_curve_simple_swu_9mod16(u[0]))),Q1=new PointG2(...math_1.isogenyMapG2(math_1.map_to_curve_simple_swu_9mod16(u[1])));return Q0.add(Q1).clearCofactor()}static fromSignature(hex){hex=ensureBytes(hex);const{P:P}=math_1.CURVE,half=hex.length/2;if(48!==half&&96!==half)throw new Error("Invalid compressed signature length, must be 96 or 192");const z1=bytesToNumberBE(hex.slice(0,half)),z2=bytesToNumberBE(hex.slice(half));if(1n===math_1.mod(z1,POW_2_383)/POW_2_382)return this.ZERO;const x1=z1%POW_2_381,x2=z2,x=new math_1.Fp2([x2,x1]);let y=x.pow(3n).add(new math_1.Fp2(math_1.CURVE.b2)).sqrt();if(!y)throw new Error("Failed to find a square root");const[y0,y1]=y.values,aflag1=z1%POW_2_382/POW_2_381;(y1>0n&&2n*y1/P!==aflag1||0n===y1&&2n*y0/P!==aflag1)&&(y=y.multiply(-1n));const point=new PointG2(x,y,math_1.Fp2.ONE);return point.assertValidity(),point}static fromHex(bytes){let point;if(96===(bytes=ensureBytes(bytes)).length)throw new Error("Compressed format not supported yet.");if(192!==bytes.length)throw new Error("Invalid uncompressed point G2, expected 192 bytes");{if(0!=(64&bytes[0]))return PointG2.ZERO;const x1=bytesToNumberBE(bytes.slice(0,48)),x0=bytesToNumberBE(bytes.slice(48,96)),y1=bytesToNumberBE(bytes.slice(96,144)),y0=bytesToNumberBE(bytes.slice(144));point=new PointG2(new math_1.Fp2([x0,x1]),new math_1.Fp2([y0,y1]))}return point.assertValidity(),point}static fromPrivateKey(privateKey){return this.BASE.multiplyPrecomputed(normalizePrivKey(privateKey))}toSignature(){if(this.equals(PointG2.ZERO)){return toPaddedHex(POW_2_383+POW_2_382,48)+toPaddedHex(0n,48)}const[[x0,x1],[y0,y1]]=this.toAffine().map((a=>a.values)),z2=x0;return toPaddedHex(x1+(y1>0n?2n*y1:2n*y0)/math_1.CURVE.P*POW_2_381+POW_2_383,48)+toPaddedHex(z2,48)}toRawBytes(isCompressed=!1){return hexToBytes(this.toHex(isCompressed))}toHex(isCompressed=!1){if(this.assertValidity(),isCompressed)throw new Error("Point compression has not yet been implemented");{if(this.equals(PointG2.ZERO))return"4".padEnd(384,"0");const[[x0,x1],[y0,y1]]=this.toAffine().map((a=>a.values));return toPaddedHex(x1,48)+toPaddedHex(x0,48)+toPaddedHex(y1,48)+toPaddedHex(y0,48)}}assertValidity(){if(this.isZero())return this;if(!this.isOnCurve())throw new Error("Invalid G2 point: not on curve Fp2");if(!this.isTorsionFree())throw new Error("Invalid G2 point: must be of prime-order subgroup");return this}psi(){return this.fromAffineTuple(math_1.psi(...this.toAffine()))}psi2(){return this.fromAffineTuple(math_1.psi2(...this.toAffine()))}mulNegX(){return this.multiplyUnsafe(math_1.CURVE.x).negate()}clearCofactor(){const P=this;let t1=P.mulNegX(),t2=P.psi(),t3=P.double();t3=t3.psi2(),t3=t3.subtract(t2),t2=t1.add(t2),t2=t2.mulNegX(),t3=t3.add(t2),t3=t3.subtract(t1);return t3.subtract(P)}isOnCurve(){const b=new math_1.Fp2(math_1.CURVE.b2),{x:x,y:y,z:z}=this,left=y.pow(2n).multiply(z).subtract(x.pow(3n)),right=b.multiply(z.pow(3n));return left.subtract(right).isZero()}isTorsionFree(){const psi2=this.psi2();return psi2.psi().mulNegX().subtract(psi2).add(this).isZero()}[Symbol.for("nodejs.util.inspect.custom")](){return this.toString()}clearPairingPrecomputes(){this._PPRECOMPUTES=void 0}pairingPrecomputes(){return this._PPRECOMPUTES||(this._PPRECOMPUTES=math_1.calcPairingPrecomputes(...this.toAffine())),this._PPRECOMPUTES}}function pairing(P,Q,withFinalExponent=!0){if(P.isZero()||Q.isZero())throw new Error("No pairings at point of Infinity");P.assertValidity(),Q.assertValidity();const looped=P.millerLoop(Q);return withFinalExponent?looped.finalExponentiate():looped}function normP1(point){return point instanceof PointG1?point:PointG1.fromHex(point)}function normP2(point){return point instanceof PointG2?point:PointG2.fromSignature(point)}async function normP2Hash(point){return point instanceof PointG2?point:PointG2.hashToCurve(point)}exports.PointG2=PointG2,PointG2.BASE=new PointG2(new math_1.Fp2(math_1.CURVE.G2x),new math_1.Fp2(math_1.CURVE.G2y),math_1.Fp2.ONE),PointG2.ZERO=new PointG2(math_1.Fp2.ONE,math_1.Fp2.ONE,math_1.Fp2.ZERO),exports.pairing=pairing,exports.getPublicKey=function(privateKey){const bytes=PointG1.fromPrivateKey(privateKey).toRawBytes(!0);return"string"==typeof privateKey?bytesToHex(bytes):bytes},exports.sign=async function(message,privateKey){const msgPoint=await normP2Hash(message);msgPoint.assertValidity();const sigPoint=msgPoint.multiply(normalizePrivKey(privateKey));if(message instanceof PointG2)return sigPoint;const hex=sigPoint.toSignature();return"string"==typeof message?hex:hexToBytes(hex)},exports.verify=async function(signature,message,publicKey){const P=normP1(publicKey),Hm=await normP2Hash(message),G=PointG1.BASE,S=normP2(signature),ePHm=pairing(P.negate(),Hm,!1);return pairing(G,S,!1).multiply(ePHm).finalExponentiate().equals(math_1.Fp12.ONE)},exports.aggregatePublicKeys=function(publicKeys){if(!publicKeys.length)throw new Error("Expected non-empty array");const agg=publicKeys.map(normP1).reduce(((sum,p)=>sum.add(p)),PointG1.ZERO);if(publicKeys[0]instanceof PointG1)return agg.assertValidity();const bytes=agg.toRawBytes(!0);return publicKeys[0]instanceof Uint8Array?bytes:bytesToHex(bytes)},exports.aggregateSignatures=function(signatures){if(!signatures.length)throw new Error("Expected non-empty array");const agg=signatures.map(normP2).reduce(((sum,s)=>sum.add(s)),PointG2.ZERO);if(signatures[0]instanceof PointG2)return agg.assertValidity();const bytes=agg.toSignature();return signatures[0]instanceof Uint8Array?hexToBytes(bytes):bytes},exports.verifyBatch=async function(signature,messages,publicKeys){if(!messages.length)throw new Error("Expected non-empty messages array");if(publicKeys.length!==messages.length)throw new Error("Pubkey count should equal msg count");const sig=normP2(signature),nMessages=await Promise.all(messages.map(normP2Hash)),nPublicKeys=publicKeys.map(normP1);try{const paired=[];for(const message of new Set(nMessages)){const groupPublicKey=nMessages.reduce(((groupPublicKey,subMessage,i)=>subMessage===message?groupPublicKey.add(nPublicKeys[i]):groupPublicKey),PointG1.ZERO);paired.push(pairing(groupPublicKey,message,!1))}paired.push(pairing(PointG1.BASE.negate(),sig,!1));const product=paired.reduce(((a,b)=>a.multiply(b)),math_1.Fp12.ONE);return product.finalExponentiate().equals(math_1.Fp12.ONE)}catch{return!1}},PointG1.BASE.calcMultiplyPrecomputes(4)}).call(this)}).call(this,require("_process"))},{"./math":6,_process:7,crypto:3}],6:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.psi2=exports.psi=exports.millerLoop=exports.calcPairingPrecomputes=exports.isogenyMapG2=exports.map_to_curve_simple_swu_9mod16=exports.ProjectivePoint=exports.Fp12=exports.Fp6=exports.Fp2=exports.Fr=exports.Fp=exports.powMod=exports.mod=exports.CURVE=void 0,exports.CURVE={P:0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn,r:0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n,h:0x396c8c005555e1568c00aaab0000aaabn,Gx:0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bbn,Gy:0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1n,b:4n,hEff:0xd201000000010001n,P2:0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn**2n-1n,h2:0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5n,G2x:[0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8n,0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7en],G2y:[0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801n,0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79ben],b2:[4n,4n],x:0xd201000000010000n,h2Eff:0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551n};const BLS_X_LEN=bitLen(exports.CURVE.x);function mod(a,b){const res=a%b;return res>=0n?res:b+res}function powMod(a,power,modulo){let res=1n;for(;power>0n;)1n&power&&(res=res*a%modulo),a=a*a%modulo,power>>=1n;return res}function bitLen(n){let len;for(len=0;n>0n;n>>=1n,len+=1);return len}function bitGet(n,pos){return n>>BigInt(pos)&1n}function invert(number,modulo=exports.CURVE.P){if(0n===number||modulo<=0n)throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);let a=mod(number,modulo),b=modulo,[x,y,u,v]=[0n,1n,1n,0n];for(;0n!==a;){const q=b/a,r=b%a,m=x-u*q,n=y-v*q;[b,a]=[a,r],[x,y]=[u,v],[u,v]=[m,n]}if(1n!==b)throw new Error("invert: does not exist");return mod(x,modulo)}exports.mod=mod,exports.powMod=powMod;class Fp{constructor(value){this.value=mod(value,Fp.ORDER)}isZero(){return 0n===this.value}equals(rhs){return this.value===rhs.value}negate(){return new Fp(-this.value)}invert(){return new Fp(invert(this.value,Fp.ORDER))}add(rhs){return new Fp(this.value+rhs.value)}square(){return new Fp(this.value*this.value)}pow(n){return new Fp(powMod(this.value,n,Fp.ORDER))}sqrt(){return new Fp(powMod(this.value,(Fp.ORDER+1n)/4n,Fp.ORDER))}subtract(rhs){return new Fp(this.value-rhs.value)}multiply(rhs){return rhs instanceof Fp&&(rhs=rhs.value),new Fp(this.value*rhs)}div(rhs){const inv="bigint"==typeof rhs?new Fp(rhs).invert().value:rhs.invert();return this.multiply(inv)}toString(){const str=this.value.toString(16).padStart(96,"0");return str.slice(0,2)+"."+str.slice(-2)}}exports.Fp=Fp,Fp.ORDER=exports.CURVE.P,Fp.MAX_BITS=bitLen(exports.CURVE.P),Fp.ZERO=new Fp(0n),Fp.ONE=new Fp(1n);class Fr{constructor(value){this.value=mod(value,Fr.ORDER)}static isValid(b){return b<=Fr.ORDER}isZero(){return 0n===this.value}equals(rhs){return this.value===rhs.value}negate(){return new Fr(-this.value)}invert(){return new Fr(invert(this.value,Fr.ORDER))}add(rhs){return new Fr(this.value+rhs.value)}square(){return new Fr(this.value*this.value)}pow(n){return new Fr(powMod(this.value,n,Fr.ORDER))}subtract(rhs){return new Fr(this.value-rhs.value)}multiply(rhs){return rhs instanceof Fr&&(rhs=rhs.value),new Fr(this.value*rhs)}div(rhs){const inv="bigint"==typeof rhs?new Fr(rhs).invert().value:rhs.invert();return this.multiply(inv)}legendre(){return this.pow((Fr.ORDER-1n)/2n)}sqrt(){if(!this.legendre().equals(Fr.ONE))return;const P=Fr.ORDER;let q,s,z;for(q=P-1n,s=0;q%2n===0n;q/=2n,s++);if(1===s)return this.pow((P+1n)/4n);for(z=2n;z<P&&new Fr(z).legendre().value!==P-1n;z++);let c=powMod(z,q,P),r=powMod(this.value,(q+1n)/2n,P),t=powMod(this.value,q,P),t2=0n;for(;0n!==mod(t-1n,P);){let i;for(t2=mod(t*t,P),i=1;i<s&&0n!==mod(t2-1n,P);i++)t2=mod(t2*t2,P);let b=powMod(c,BigInt(1<<s-i-1),P);r=mod(r*b,P),c=mod(b*b,P),t=mod(t*c,P),s=i}return new Fr(r)}toString(){return"0x"+this.value.toString(16).padStart(64,"0")}}exports.Fr=Fr,Fr.ORDER=exports.CURVE.r,Fr.ZERO=new Fr(0n),Fr.ONE=new Fr(1n);class FQP{zip(rhs,mapper){const c0=this.c,c1=rhs.c,res=[];for(let i=0;i<c0.length;i++)res.push(mapper(c0[i],c1[i]));return res}map(callbackfn){return this.c.map(callbackfn)}isZero(){return this.c.every((c=>c.isZero()))}equals(rhs){return this.zip(rhs,((left,right)=>left.equals(right))).every((r=>r))}negate(){return this.init(this.map((c=>c.negate())))}add(rhs){return this.init(this.zip(rhs,((left,right)=>left.add(right))))}subtract(rhs){return this.init(this.zip(rhs,((left,right)=>left.subtract(right))))}conjugate(){return this.init([this.c[0],this.c[1].negate()])}one(){let one;return this instanceof Fp2&&(one=Fp2.ONE),this instanceof Fp6&&(one=Fp6.ONE),this instanceof Fp12&&(one=Fp12.ONE),one}pow(n){const one=this.one();if(0n===n)return one;if(1n===n)return this;let p=one,d=this;for(;n>0n;)1n&n&&(p=p.multiply(d)),n>>=1n,d=d.square();return p}div(rhs){const inv="bigint"==typeof rhs?new Fp(rhs).invert().value:rhs.invert();return this.multiply(inv)}}class Fp2 extends FQP{constructor(coeffs){if(super(),2!==coeffs.length)throw new Error("Expected array with 2 elements");coeffs.forEach(((c,i)=>{"bigint"==typeof c&&(coeffs[i]=new Fp(c))})),this.c=coeffs}init(tuple){return new Fp2(tuple)}toString(){return`Fp2(${this.c[0]} + ${this.c[1]}Ã—i)`}get values(){return this.c.map((c=>c.value))}multiply(rhs){if("bigint"==typeof rhs)return new Fp2(this.map((c=>c.multiply(rhs))));const[c0,c1]=this.c,[r0,r1]=rhs.c;let t1=c0.multiply(r0),t2=c1.multiply(r1);return new Fp2([t1.subtract(t2),c0.add(c1).multiply(r0.add(r1)).subtract(t1.add(t2))])}mulByNonresidue(){const c0=this.c[0],c1=this.c[1];return new Fp2([c0.subtract(c1),c0.add(c1)])}square(){const c0=this.c[0],c1=this.c[1],a=c0.add(c1),b=c0.subtract(c1),c=c0.add(c0);return new Fp2([a.multiply(b),c.multiply(c1)])}sqrt(){const candidateSqrt=this.pow((Fp2.ORDER+8n)/16n),check=candidateSqrt.square().div(this),R=FP2_ROOTS_OF_UNITY,divisor=[R[0],R[2],R[4],R[6]].find((r=>r.equals(check)));if(!divisor)return;const index=R.indexOf(divisor),root=R[index/2];if(!root)throw new Error("Invalid root");const x1=candidateSqrt.div(root),x2=x1.negate(),[re1,im1]=x1.values,[re2,im2]=x2.values;return im1>im2||im1===im2&&re1>re2?x1:x2}invert(){const[a,b]=this.values,factor=new Fp(a*a+b*b).invert();return new Fp2([factor.multiply(new Fp(a)),factor.multiply(new Fp(-b))])}frobeniusMap(power){return new Fp2([this.c[0],this.c[1].multiply(FP2_FROBENIUS_COEFFICIENTS[power%2])])}multiplyByB(){let[c0,c1]=this.c,t0=c0.multiply(4n),t1=c1.multiply(4n);return new Fp2([t0.subtract(t1),t0.add(t1)])}}exports.Fp2=Fp2,Fp2.ORDER=exports.CURVE.P2,Fp2.MAX_BITS=bitLen(exports.CURVE.P2),Fp2.ZERO=new Fp2([0n,0n]),Fp2.ONE=new Fp2([1n,0n]);class Fp6 extends FQP{constructor(c){if(super(),this.c=c,3!==c.length)throw new Error("Expected array with 3 elements")}static fromTuple(t){if(!Array.isArray(t)||6!==t.length)throw new Error("Invalid Fp6 usage");return new Fp6([new Fp2(t.slice(0,2)),new Fp2(t.slice(2,4)),new Fp2(t.slice(4,6))])}init(triple){return new Fp6(triple)}toString(){return`Fp6(${this.c[0]} + ${this.c[1]} * v, ${this.c[2]} * v^2)`}conjugate(){throw new TypeError("No conjugate on Fp6")}multiply(rhs){if("bigint"==typeof rhs)return new Fp6([this.c[0].multiply(rhs),this.c[1].multiply(rhs),this.c[2].multiply(rhs)]);let[c0,c1,c2]=this.c;const[r0,r1,r2]=rhs.c;let t0=c0.multiply(r0),t1=c1.multiply(r1),t2=c2.multiply(r2);return new Fp6([t0.add(c1.add(c2).multiply(r1.add(r2)).subtract(t1.add(t2)).mulByNonresidue()),c0.add(c1).multiply(r0.add(r1)).subtract(t0.add(t1)).add(t2.mulByNonresidue()),t1.add(c0.add(c2).multiply(r0.add(r2)).subtract(t0.add(t2)))])}mulByNonresidue(){return new Fp6([this.c[2].mulByNonresidue(),this.c[0],this.c[1]])}multiplyBy1(b1){return new Fp6([this.c[2].multiply(b1).mulByNonresidue(),this.c[0].multiply(b1),this.c[1].multiply(b1)])}multiplyBy01(b0,b1){let[c0,c1,c2]=this.c,t0=c0.multiply(b0),t1=c1.multiply(b1);return new Fp6([c1.add(c2).multiply(b1).subtract(t1).mulByNonresidue().add(t0),b0.add(b1).multiply(c0.add(c1)).subtract(t0).subtract(t1),c0.add(c2).multiply(b0).subtract(t0).add(t1)])}multiplyByFp2(rhs){return new Fp6(this.map((c=>c.multiply(rhs))))}square(){let[c0,c1,c2]=this.c,t0=c0.square(),t1=c0.multiply(c1).multiply(2n),t3=c1.multiply(c2).multiply(2n),t4=c2.square();return new Fp6([t3.mulByNonresidue().add(t0),t4.mulByNonresidue().add(t1),t1.add(c0.subtract(c1).add(c2).square()).add(t3).subtract(t0).subtract(t4)])}invert(){let[c0,c1,c2]=this.c,t0=c0.square().subtract(c2.multiply(c1).mulByNonresidue()),t1=c2.square().mulByNonresidue().subtract(c0.multiply(c1)),t2=c1.square().subtract(c0.multiply(c2)),t4=c2.multiply(t1).add(c1.multiply(t2)).mulByNonresidue().add(c0.multiply(t0)).invert();return new Fp6([t4.multiply(t0),t4.multiply(t1),t4.multiply(t2)])}frobeniusMap(power){return new Fp6([this.c[0].frobeniusMap(power),this.c[1].frobeniusMap(power).multiply(FP6_FROBENIUS_COEFFICIENTS_1[power%6]),this.c[2].frobeniusMap(power).multiply(FP6_FROBENIUS_COEFFICIENTS_2[power%6])])}}exports.Fp6=Fp6,Fp6.ZERO=new Fp6([Fp2.ZERO,Fp2.ZERO,Fp2.ZERO]),Fp6.ONE=new Fp6([Fp2.ONE,Fp2.ZERO,Fp2.ZERO]);class Fp12 extends FQP{constructor(c){if(super(),this.c=c,2!==c.length)throw new Error("Expected array with 2 elements")}static fromTuple(t){return new Fp12([Fp6.fromTuple(t.slice(0,6)),Fp6.fromTuple(t.slice(6,12))])}init(c){return new Fp12(c)}toString(){return`Fp12(${this.c[0]} + ${this.c[1]} * w)`}multiply(rhs){if("bigint"==typeof rhs)return new Fp12([this.c[0].multiply(rhs),this.c[1].multiply(rhs)]);let[c0,c1]=this.c;const[r0,r1]=rhs.c;let t1=c0.multiply(r0),t2=c1.multiply(r1);return new Fp12([t1.add(t2.mulByNonresidue()),c0.add(c1).multiply(r0.add(r1)).subtract(t1.add(t2))])}multiplyBy014(o0,o1,o4){let[c0,c1]=this.c,[t0,t1]=[c0.multiplyBy01(o0,o1),c1.multiplyBy1(o4)];return new Fp12([t1.mulByNonresidue().add(t0),c1.add(c0).multiplyBy01(o0,o1.add(o4)).subtract(t0).subtract(t1)])}multiplyByFp2(rhs){return this.init(this.map((c=>c.multiplyByFp2(rhs))))}square(){let[c0,c1]=this.c,ab=c0.multiply(c1);return new Fp12([c1.mulByNonresidue().add(c0).multiply(c0.add(c1)).subtract(ab).subtract(ab.mulByNonresidue()),ab.add(ab)])}invert(){let[c0,c1]=this.c,t=c0.square().subtract(c1.square().mulByNonresidue()).invert();return new Fp12([c0.multiply(t),c1.multiply(t).negate()])}frobeniusMap(power){const[c0,c1]=this.c;let r0=c0.frobeniusMap(power),[c1_0,c1_1,c1_2]=c1.frobeniusMap(power).c;const coeff=FP12_FROBENIUS_COEFFICIENTS[power%12];return new Fp12([r0,new Fp6([c1_0.multiply(coeff),c1_1.multiply(coeff),c1_2.multiply(coeff)])])}Fp4Square(a,b){const a2=a.square(),b2=b.square();return[b2.mulByNonresidue().add(a2),a.add(b).square().subtract(a2).subtract(b2)]}cyclotomicSquare(){const[c0,c1]=this.c,[c0c0,c0c1,c0c2]=c0.c,[c1c0,c1c1,c1c2]=c1.c;let[t3,t4]=this.Fp4Square(c0c0,c1c1),[t5,t6]=this.Fp4Square(c1c0,c0c2),[t7,t8]=this.Fp4Square(c0c1,c1c2),t9=t8.mulByNonresidue();return new Fp12([new Fp6([t3.subtract(c0c0).multiply(2n).add(t3),t5.subtract(c0c1).multiply(2n).add(t5),t7.subtract(c0c2).multiply(2n).add(t7)]),new Fp6([t9.add(c1c0).multiply(2n).add(t9),t4.add(c1c1).multiply(2n).add(t4),t6.add(c1c2).multiply(2n).add(t6)])])}cyclotomicExp(n){let z=Fp12.ONE;for(let i=BLS_X_LEN-1;i>=0;i--)z=z.cyclotomicSquare(),bitGet(n,i)&&(z=z.multiply(this));return z}finalExponentiate(){const{x:x}=exports.CURVE,t0=this.frobeniusMap(6).div(this),t1=t0.frobeniusMap(2).multiply(t0),t2=t1.cyclotomicExp(x).conjugate(),t3=t1.cyclotomicSquare().conjugate().multiply(t2),t4=t3.cyclotomicExp(x).conjugate(),t5=t4.cyclotomicExp(x).conjugate(),t6=t5.cyclotomicExp(x).conjugate().multiply(t2.cyclotomicSquare()),t7=t6.cyclotomicExp(x).conjugate(),t2_t5_pow_q2=t2.multiply(t5).frobeniusMap(2),t4_t1_pow_q3=t4.multiply(t1).frobeniusMap(3),t6_t1c_pow_q1=t6.multiply(t1.conjugate()).frobeniusMap(1),t7_t3c_t1=t7.multiply(t3.conjugate()).multiply(t1);return t2_t5_pow_q2.multiply(t4_t1_pow_q3).multiply(t6_t1c_pow_q1).multiply(t7_t3c_t1)}}exports.Fp12=Fp12,Fp12.ZERO=new Fp12([Fp6.ZERO,Fp6.ZERO]),Fp12.ONE=new Fp12([Fp6.ONE,Fp6.ZERO]);function sgn0(x){const[x0,x1]=x.values;return BigInt(x0%2n||0n===x0&&x1%2n)}exports.ProjectivePoint=class{constructor(x,y,z,C){this.x=x,this.y=y,this.z=z,this.C=C}isZero(){return this.z.isZero()}createPoint(x,y,z){return new this.constructor(x,y,z)}getZero(){return this.createPoint(this.C.ONE,this.C.ONE,this.C.ZERO)}equals(rhs){if(this.constructor!==rhs.constructor)throw new Error(`ProjectivePoint#equals: this is ${this.constructor}, but rhs is ${rhs.constructor}`);const a=this,b=rhs,xe=a.x.multiply(b.z).equals(b.x.multiply(a.z)),ye=a.y.multiply(b.z).equals(b.y.multiply(a.z));return xe&&ye}negate(){return this.createPoint(this.x,this.y.negate(),this.z)}toString(isAffine=!0){if(!isAffine)return`Point<x=${this.x}, y=${this.y}, z=${this.z}>`;const[x,y]=this.toAffine();return`Point<x=${x}, y=${y}>`}fromAffineTuple(xy){return this.createPoint(xy[0],xy[1],this.C.ONE)}toAffine(invZ=this.z.invert()){return[this.x.multiply(invZ),this.y.multiply(invZ)]}toAffineBatch(points){const toInv=function(cls,nums){const len=nums.length,scratch=new Array(len);let acc=cls.ONE;for(let i=0;i<len;i++)nums[i].isZero()||(scratch[i]=acc,acc=acc.multiply(nums[i]));acc=acc.invert();for(let i=len-1;i>=0;i--){if(nums[i].isZero())continue;let tmp=acc.multiply(nums[i]);nums[i]=acc.multiply(scratch[i]),acc=tmp}return nums}(this.C,points.map((p=>p.z)));return points.map(((p,i)=>p.toAffine(toInv[i])))}normalizeZ(points){return this.toAffineBatch(points).map((t=>this.fromAffineTuple(t)))}double(){const{x:x,y:y,z:z}=this,W=x.multiply(x).multiply(3n),S=y.multiply(z),SS=S.multiply(S),SSS=SS.multiply(S),B=x.multiply(y).multiply(S),H=W.multiply(W).subtract(B.multiply(8n)),X3=H.multiply(S).multiply(2n),Y3=W.multiply(B.multiply(4n).subtract(H)).subtract(y.multiply(y).multiply(8n).multiply(SS)),Z3=SSS.multiply(8n);return this.createPoint(X3,Y3,Z3)}add(rhs){if(this.constructor!==rhs.constructor)throw new Error(`ProjectivePoint#add: this is ${this.constructor}, but rhs is ${rhs.constructor}`);const p1=this,p2=rhs;if(p1.isZero())return p2;if(p2.isZero())return p1;const X1=p1.x,Y1=p1.y,Z1=p1.z,X2=p2.x,Y2=p2.y,Z2=p2.z,U1=Y2.multiply(Z1),U2=Y1.multiply(Z2),V1=X2.multiply(Z1),V2=X1.multiply(Z2);if(V1.equals(V2)&&U1.equals(U2))return this.double();if(V1.equals(V2))return this.getZero();const U=U1.subtract(U2),V=V1.subtract(V2),VV=V.multiply(V),VVV=VV.multiply(V),V2VV=V2.multiply(VV),W=Z1.multiply(Z2),A=U.multiply(U).multiply(W).subtract(VVV).subtract(V2VV.multiply(2n)),X3=V.multiply(A),Y3=U.multiply(V2VV.subtract(A)).subtract(VVV.multiply(U2)),Z3=VVV.multiply(W);return this.createPoint(X3,Y3,Z3)}subtract(rhs){if(this.constructor!==rhs.constructor)throw new Error(`ProjectivePoint#subtract: this is ${this.constructor}, but rhs is ${rhs.constructor}`);return this.add(rhs.negate())}validateScalar(n){if("number"==typeof n&&(n=BigInt(n)),"bigint"!=typeof n||n<=0||n>exports.CURVE.r)throw new Error(`Point#multiply: invalid scalar, expected positive integer < CURVE.r. Got: ${n}`);return n}multiplyUnsafe(scalar){let n=this.validateScalar(scalar),point=this.getZero(),d=this;for(;n>0n;)1n&n&&(point=point.add(d)),d=d.double(),n>>=1n;return point}multiply(scalar){let n=this.validateScalar(scalar),point=this.getZero(),fake=this.getZero(),d=this,bits=Fp.ORDER;for(;bits>0n;)1n&n?point=point.add(d):fake=fake.add(d),d=d.double(),n>>=1n,bits>>=1n;return point}maxBits(){return this.C.MAX_BITS}precomputeWindow(W){const windows=Math.ceil(this.maxBits()/W),windowSize=2**(W-1);let points=[],p=this,base=p;for(let window=0;window<windows;window++){base=p,points.push(base);for(let i=1;i<windowSize;i++)base=base.add(p),points.push(base);p=base.double()}return points}calcMultiplyPrecomputes(W){if(this._MPRECOMPUTES)throw new Error("This point already has precomputes");this._MPRECOMPUTES=[W,this.normalizeZ(this.precomputeWindow(W))]}clearMultiplyPrecomputes(){this._MPRECOMPUTES=void 0}wNAF(n){let W,precomputes;this._MPRECOMPUTES?[W,precomputes]=this._MPRECOMPUTES:(W=1,precomputes=this.precomputeWindow(W));let[p,f]=[this.getZero(),this.getZero()];const windows=Math.ceil(this.maxBits()/W),windowSize=2**(W-1),mask=BigInt(2**W-1),maxNumber=2**W,shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);if(n>>=shiftBy,wbits>windowSize&&(wbits-=maxNumber,n+=1n),0===wbits)f=f.add(window%2?precomputes[offset].negate():precomputes[offset]);else{const cached=precomputes[offset+Math.abs(wbits)-1];p=p.add(wbits<0?cached.negate():cached)}}return[p,f]}multiplyPrecomputed(scalar){return this.wNAF(this.validateScalar(scalar))[0]}};const P_MINUS_9_DIV_16=(exports.CURVE.P**2n-9n)/16n;exports.map_to_curve_simple_swu_9mod16=function(t){const iso_3_a=new Fp2([0n,240n]),iso_3_b=new Fp2([1012n,1012n]),iso_3_z=new Fp2([-2n,-1n]);Array.isArray(t)&&(t=new Fp2(t));const t2=t.pow(2n),iso_3_z_t2=iso_3_z.multiply(t2),ztzt=iso_3_z_t2.add(iso_3_z_t2.pow(2n));let denominator=iso_3_a.multiply(ztzt).negate(),numerator=iso_3_b.multiply(ztzt.add(Fp2.ONE));denominator.isZero()&&(denominator=iso_3_z.multiply(iso_3_a));let v=denominator.pow(3n),u=numerator.pow(3n).add(iso_3_a.multiply(numerator).multiply(denominator.pow(2n))).add(iso_3_b.multiply(v));const[success,sqrtCandidateOrGamma]=function(u,v){const v7=v.pow(7n),uv7=u.multiply(v7),gamma=uv7.multiply(v7.multiply(v)).pow(P_MINUS_9_DIV_16).multiply(uv7);let success=!1,result=gamma;const positiveRootsOfUnity=FP2_ROOTS_OF_UNITY.slice(0,4);for(const root of positiveRootsOfUnity){const candidate=root.multiply(gamma);candidate.pow(2n).multiply(v).subtract(u).isZero()&&!success&&(success=!0,result=candidate)}return[success,result]}(u,v);let y;success&&(y=sqrtCandidateOrGamma);const sqrtCandidateX1=sqrtCandidateOrGamma.multiply(t.pow(3n));u=iso_3_z_t2.pow(3n).multiply(u);let success2=!1;for(const eta of FP2_ETAs){const etaSqrtCandidate=eta.multiply(sqrtCandidateX1);!etaSqrtCandidate.pow(2n).multiply(v).subtract(u).isZero()||success||success2||(y=etaSqrtCandidate,success2=!0)}if(!success&&!success2)throw new Error("Hash to Curve - Optimized SWU failure");return success2&&(numerator=numerator.multiply(iso_3_z_t2)),y=y,sgn0(t)!==sgn0(y)&&(y=y.negate()),y=y.multiply(denominator),[numerator,y,denominator]},exports.isogenyMapG2=function(xyz){const[x,y,z]=xyz,zz=z.multiply(z),zzz=zz.multiply(z),zPowers=[z,zz,zzz],mapped=[Fp2.ZERO,Fp2.ZERO,Fp2.ZERO,Fp2.ZERO];for(let i=0;i<ISOGENY_COEFFICIENTS.length;i++){const k_i=ISOGENY_COEFFICIENTS[i];mapped[i]=k_i.slice(-1)[0];const arr=k_i.slice(0,-1).reverse();for(let j=0;j<arr.length;j++){const k_i_j=arr[j];mapped[i]=mapped[i].multiply(x).add(zPowers[j].multiply(k_i_j))}}mapped[2]=mapped[2].multiply(y),mapped[3]=mapped[3].multiply(z);const z2=mapped[1].multiply(mapped[3]);return[mapped[0].multiply(mapped[3]),mapped[1].multiply(mapped[2]),z2]},exports.calcPairingPrecomputes=function(x,y){const[Qx,Qy,Qz]=[x,y,Fp2.ONE];let[Rx,Ry,Rz]=[Qx,Qy,Qz],ell_coeff=[];for(let i=BLS_X_LEN-2;i>=0;i--){let t0=Ry.square(),t1=Rz.square(),t2=t1.multiply(3n).multiplyByB(),t3=t2.multiply(3n),t4=Ry.add(Rz).square().subtract(t1).subtract(t0);if(ell_coeff.push([t2.subtract(t0),Rx.square().multiply(3n),t4.negate()]),Rx=t0.subtract(t3).multiply(Rx).multiply(Ry).div(2n),Ry=t0.add(t3).div(2n).square().subtract(t2.square().multiply(3n)),Rz=t0.multiply(t4),bitGet(exports.CURVE.x,i)){let t0=Ry.subtract(Qy.multiply(Rz)),t1=Rx.subtract(Qx.multiply(Rz));ell_coeff.push([t0.multiply(Qx).subtract(t1.multiply(Qy)),t0.negate(),t1]);let t2=t1.square(),t3=t2.multiply(t1),t4=t2.multiply(Rx),t5=t3.subtract(t4.multiply(2n)).add(t0.square().multiply(Rz));Rx=t1.multiply(t5),Ry=t4.subtract(t5).multiply(t0).subtract(t3.multiply(Ry)),Rz=Rz.multiply(t3)}}return ell_coeff},exports.millerLoop=function(ell,g1){let f12=Fp12.ONE;const[x,y]=g1,[Px,Py]=[x,y];for(let j=0,i=BLS_X_LEN-2;i>=0;i--,j++)f12=f12.multiplyBy014(ell[j][0],ell[j][1].multiply(Px.value),ell[j][2].multiply(Py.value)),bitGet(exports.CURVE.x,i)&&(j+=1,f12=f12.multiplyBy014(ell[j][0],ell[j][1].multiply(Px.value),ell[j][2].multiply(Py.value))),0!==i&&(f12=f12.square());return f12.conjugate()};const ut_root=new Fp6([Fp2.ZERO,Fp2.ONE,Fp2.ZERO]),wsq=new Fp12([ut_root,Fp6.ZERO]),wsq_inv=wsq.invert(),wcu=new Fp12([Fp6.ZERO,ut_root]),wcu_inv=wcu.invert();exports.psi=function(x,y){return[wsq_inv.multiplyByFp2(x).frobeniusMap(1).multiply(wsq).c[0].c[0],wcu_inv.multiplyByFp2(y).frobeniusMap(1).multiply(wcu).c[0].c[0]]},exports.psi2=function(x,y){return[x.multiply(PSI2_C1),y.negate()]};const PSI2_C1=0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaacn,rv1=0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09n,ev1=0x699be3b8c6870965e5bf892ad5d2cc7b0e85a117402dfd83b7f4a947e02d978498255a2aaec0ac627b5afbdf1bf1c90n,ev2=0x8157cd83046453f5dd0972b6e3949e4288020b5b8a9cc99ca07e27089a2ce2436d965026adad3ef7baba37f2183e9b5n,ev3=0xab1c2ffdd6c253ca155231eb3e71ba044fd562f6f72bc5bad5ec46a0b7a3b0247cf08ce6c6317f40edbc653a72dee17n,ev4=0xaa404866706722864480885d68ad0ccac1967c7544b447873cc37e0181271e006df72162a3d3e0287bf597fbf7f8fc1n,FP2_FROBENIUS_COEFFICIENTS=[0x1n,0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaan].map((item=>new Fp(item))),FP2_ROOTS_OF_UNITY=[[1n,0n],[rv1,-rv1],[0n,1n],[rv1,rv1],[-1n,0n],[-rv1,rv1],[0n,-1n],[-rv1,-rv1]].map((pair=>new Fp2(pair))),FP2_ETAs=[[ev1,ev2],[-ev2,ev1],[ev3,ev4],[-ev4,ev3]].map((pair=>new Fp2(pair))),FP6_FROBENIUS_COEFFICIENTS_1=[[0x1n,0x0n],[0x0n,0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaacn],[0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffen,0x0n],[0x0n,0x1n],[0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaacn,0x0n],[0x0n,0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffen]].map((pair=>new Fp2(pair))),FP6_FROBENIUS_COEFFICIENTS_2=[[0x1n,0x0n],[0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaadn,0x0n],[0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaacn,0x0n],[0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaan,0x0n],[0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffen,0x0n],[0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffffn,0x0n]].map((pair=>new Fp2(pair))),FP12_FROBENIUS_COEFFICIENTS=[[0x1n,0x0n],[0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8n,0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3n],[0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffffn,0x0n],[0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2n,0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09n],[0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffen,0x0n],[0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995n,0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116n],[0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaan,0x0n],[0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3n,0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8n],[0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaacn,0x0n],[0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09n,0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2n],[0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaadn,0x0n],[0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116n,0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995n]].map((pair=>new Fp2(pair))),ISOGENY_COEFFICIENTS=[[[0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6n,0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6n],[0x0n,0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71an],[0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71en,0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38dn],[0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1n,0x0n]].map((pair=>new Fp2(pair))),[[0x0n,0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63n],[0xcn,0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9fn],[0x1n,0x0n],[0x0n,0x0n]].map((pair=>new Fp2(pair))),[[0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706n,0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706n],[0x0n,0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97ben],[0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71cn,0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38fn],[0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10n,0x0n]].map((pair=>new Fp2(pair))),[[0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fbn,0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fbn],[0x0n,0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3n],[0x12n,0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99n],[0x1n,0x0n]].map((pair=>new Fp2(pair)))]},{}],7:[function(require,module,exports){var cachedSetTimeout,cachedClearTimeout,process=module.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(fun){if(cachedSetTimeout===setTimeout)return setTimeout(fun,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(fun,0);try{return cachedSetTimeout(fun,0)}catch(e){try{return cachedSetTimeout.call(null,fun,0)}catch(e){return cachedSetTimeout.call(this,fun,0)}}}!function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}}();var currentQueue,queue=[],draining=!1,queueIndex=-1;function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var timeout=runTimeout(cleanUpNextTick);draining=!0;for(var len=queue.length;len;){for(currentQueue=queue,queue=[];++queueIndex<len;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,len=queue.length}currentQueue=null,draining=!1,function(marker){if(cachedClearTimeout===clearTimeout)return clearTimeout(marker);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(marker);try{cachedClearTimeout(marker)}catch(e){try{return cachedClearTimeout.call(null,marker)}catch(e){return cachedClearTimeout.call(this,marker)}}}(timeout)}}function Item(fun,array){this.fun=fun,this.array=array}function noop(){}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)args[i-1]=arguments[i];queue.push(new Item(fun,args)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.prependListener=noop,process.prependOnceListener=noop,process.listeners=function(name){return[]},process.binding=function(name){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(dir){throw new Error("process.chdir is not supported")},process.umask=function(){return 0}},{}]},{},[1])(1)}));
